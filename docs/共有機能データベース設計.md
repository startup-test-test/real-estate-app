# 共有・招待機能 データベース設計

## 1. テーブル設計

### 1.1 property_shares（物件共有）テーブル
```sql
CREATE TABLE property_shares (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES properties(id),
  owner_id UUID NOT NULL REFERENCES auth.users(id),
  share_token VARCHAR(255) UNIQUE NOT NULL,
  title VARCHAR(255),
  description TEXT,
  settings JSONB DEFAULT '{}',
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_property_shares_owner ON property_shares(owner_id);
CREATE INDEX idx_property_shares_token ON property_shares(share_token);
```

### 1.2 share_invitations（招待）テーブル
```sql
CREATE TABLE share_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_id UUID NOT NULL REFERENCES property_shares(id) ON DELETE CASCADE,
  email VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL CHECK (role IN ('viewer', 'commenter', 'editor')),
  user_type VARCHAR(50) DEFAULT 'general', -- 'family', 'tax_accountant', 'consultant', 'general'
  invited_by UUID NOT NULL REFERENCES auth.users(id),
  accepted_by UUID REFERENCES auth.users(id),
  invitation_token VARCHAR(255) UNIQUE NOT NULL,
  status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
  message TEXT,
  accepted_at TIMESTAMP WITH TIME ZONE,
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_invitations_share ON share_invitations(share_id);
CREATE INDEX idx_invitations_email ON share_invitations(email);
CREATE INDEX idx_invitations_token ON share_invitations(invitation_token);
```

### 1.3 share_comments（コメント）テーブル
```sql
CREATE TABLE share_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_id UUID NOT NULL REFERENCES property_shares(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  parent_id UUID REFERENCES share_comments(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  tags TEXT[] DEFAULT '{}',
  attachments JSONB DEFAULT '[]',
  metadata JSONB DEFAULT '{}',
  is_edited BOOLEAN DEFAULT FALSE,
  edited_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_comments_share ON share_comments(share_id);
CREATE INDEX idx_comments_user ON share_comments(user_id);
CREATE INDEX idx_comments_parent ON share_comments(parent_id);
CREATE INDEX idx_comments_created ON share_comments(created_at DESC);
```

### 1.4 comment_reactions（リアクション）テーブル
```sql
CREATE TABLE comment_reactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id UUID NOT NULL REFERENCES share_comments(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  reaction VARCHAR(10) NOT NULL, -- '👍', '👎', '❓', etc.
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(comment_id, user_id, reaction)
);

-- インデックス
CREATE INDEX idx_reactions_comment ON comment_reactions(comment_id);
```

### 1.5 share_access_logs（アクセスログ）テーブル
```sql
CREATE TABLE share_access_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_id UUID NOT NULL REFERENCES property_shares(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  invitation_id UUID REFERENCES share_invitations(id),
  action VARCHAR(50) NOT NULL, -- 'view', 'comment', 'edit', 'download'
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_access_logs_share ON share_access_logs(share_id);
CREATE INDEX idx_access_logs_user ON share_access_logs(user_id);
CREATE INDEX idx_access_logs_created ON share_access_logs(created_at DESC);
```

## 2. ビューの作成

### 2.1 共有概要ビュー
```sql
CREATE VIEW share_overview AS
SELECT 
  ps.id,
  ps.property_id,
  ps.owner_id,
  ps.title,
  ps.created_at,
  COUNT(DISTINCT si.id) as invitation_count,
  COUNT(DISTINCT CASE WHEN si.status = 'accepted' THEN si.id END) as active_users,
  COUNT(DISTINCT sc.id) as comment_count,
  MAX(sc.created_at) as last_activity
FROM property_shares ps
LEFT JOIN share_invitations si ON ps.id = si.share_id
LEFT JOIN share_comments sc ON ps.id = sc.share_id
GROUP BY ps.id;
```

### 2.2 ユーザー別アクセス権限ビュー
```sql
CREATE VIEW user_share_permissions AS
SELECT 
  ps.id as share_id,
  ps.property_id,
  ps.owner_id,
  si.accepted_by as user_id,
  si.role,
  si.user_type,
  si.accepted_at,
  CASE 
    WHEN ps.owner_id = si.accepted_by THEN 'owner'
    ELSE si.role
  END as effective_role
FROM property_shares ps
JOIN share_invitations si ON ps.id = si.share_id
WHERE si.status = 'accepted'
UNION
SELECT 
  id as share_id,
  property_id,
  owner_id,
  owner_id as user_id,
  'owner' as role,
  'owner' as user_type,
  created_at as accepted_at,
  'owner' as effective_role
FROM property_shares;
```

## 3. Row Level Security (RLS) ポリシー

### 3.1 property_shares テーブル
```sql
-- 読み取り: オーナーまたは招待を受けたユーザー
CREATE POLICY "Users can view shares they have access to" ON property_shares
  FOR SELECT USING (
    auth.uid() = owner_id OR
    EXISTS (
      SELECT 1 FROM share_invitations
      WHERE share_id = property_shares.id
      AND accepted_by = auth.uid()
      AND status = 'accepted'
    )
  );

-- 作成: 認証されたユーザー
CREATE POLICY "Authenticated users can create shares" ON property_shares
  FOR INSERT WITH CHECK (auth.uid() = owner_id);

-- 更新: オーナーのみ
CREATE POLICY "Owners can update their shares" ON property_shares
  FOR UPDATE USING (auth.uid() = owner_id);

-- 削除: オーナーのみ
CREATE POLICY "Owners can delete their shares" ON property_shares
  FOR DELETE USING (auth.uid() = owner_id);
```

### 3.2 share_comments テーブル
```sql
-- 読み取り: 共有にアクセスできるユーザー
CREATE POLICY "Users can view comments on accessible shares" ON share_comments
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_share_permissions
      WHERE share_id = share_comments.share_id
      AND user_id = auth.uid()
    )
  );

-- 作成: コメント権限以上を持つユーザー
CREATE POLICY "Users with comment permission can create comments" ON share_comments
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_share_permissions
      WHERE share_id = share_comments.share_id
      AND user_id = auth.uid()
      AND effective_role IN ('owner', 'editor', 'commenter')
    )
  );
```

## 4. 関数とトリガー

### 4.1 招待トークン生成関数
```sql
CREATE OR REPLACE FUNCTION generate_invitation_token()
RETURNS TEXT AS $$
BEGIN
  RETURN encode(gen_random_bytes(32), 'hex');
END;
$$ LANGUAGE plpgsql;
```

### 4.2 コメント通知トリガー
```sql
CREATE OR REPLACE FUNCTION notify_new_comment()
RETURNS TRIGGER AS $$
BEGIN
  -- 通知ロジックを実装
  -- 例: メール送信、プッシュ通知など
  PERFORM pg_notify('new_comment', json_build_object(
    'share_id', NEW.share_id,
    'comment_id', NEW.id,
    'user_id', NEW.user_id
  )::text);
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notify_new_comment
  AFTER INSERT ON share_comments
  FOR EACH ROW
  EXECUTE FUNCTION notify_new_comment();
```

## 5. インデックス戦略

### パフォーマンス最適化のためのインデックス
```sql
-- 複合インデックス
CREATE INDEX idx_invitations_status_share ON share_invitations(status, share_id);
CREATE INDEX idx_comments_share_created ON share_comments(share_id, created_at DESC);

-- 部分インデックス
CREATE INDEX idx_active_invitations ON share_invitations(share_id)
  WHERE status = 'accepted';

-- GINインデックス（タグ検索用）
CREATE INDEX idx_comments_tags ON share_comments USING GIN(tags);
```

## 6. セキュリティ考慮事項

1. **トークンの安全性**
   - 招待トークンは推測困難な長さ（256bit）
   - 有効期限の設定

2. **アクセス制御**
   - RLSによる行レベルのアクセス制御
   - 役割ベースの権限管理

3. **監査証跡**
   - すべてのアクセスをログに記録
   - 重要な操作の履歴保持

4. **データ保護**
   - 個人情報の暗号化
   - 定期的なバックアップ