# 無限ループ問題の原因と対処法

## 概要
このドキュメントは、React開発において頻繁に発生する無限ループ問題の原因と対処法をまとめたものです。特に、Dashboardコンポーネントで2025年7月30日に発生した問題を事例として記録します。

## 発生日時と症状
- **発生日**: 2025年7月30日
- **場所**: `/bolt_front/src/pages/Dashboard.tsx`
- **症状**: 
  - データ取得処理が無限に繰り返される
  - ブラウザが重くなり、最終的にクラッシュする可能性がある
  - コンソールに同じログが繰り返し出力される

## 根本原因

### 1. useEffectの依存配列にuserオブジェクトを含めていた

```typescript
// 問題のあるコード
React.useEffect(() => {
  if (user) {
    loadSimulations();
  }
}, [user]); // ❌ userオブジェクトが依存配列に含まれている
```

### 原因の詳細説明
1. **オブジェクトの参照比較問題**
   - JavaScriptでは、オブジェクトは参照で比較される
   - AuthProviderから返されるuserオブジェクトは、内容が同じでも毎回新しい参照を持つ可能性がある
   - Reactは依存配列の変更を厳密等価（===）で判定する

2. **レンダリングサイクル**
   ```
   1. コンポーネントがレンダリングされる
   2. AuthProviderがuserオブジェクトを返す（新しい参照）
   3. useEffectが実行される（userの参照が変わったため）
   4. loadSimulations()が実行される
   5. setState()によりコンポーネントが再レンダリングされる
   6. 1に戻る（無限ループ）
   ```

## 実装した対処法

### 1. 依存配列からuserを削除
```typescript
// 修正後のコード
React.useEffect(() => {
  console.log('Dashboard useEffect: 初回読み込み', { user: user?.email, authLoading })
  if (!authLoading) {
    loadSimulations();
  }
}, [authLoading]); // ✅ userを依存配列から削除
```

### 2. loadSimulations関数内でuserをチェック
```typescript
const loadSimulations = async (forceRefresh = false) => {
  if (!user) {
    console.log('loadSimulations: ユーザーが登録されていません')
    return;
  }
  // 以下、データ取得処理
};
```

### 3. キャッシュ機能の実装
無限ループを防ぎつつ、パフォーマンスを向上させるためにキャッシュ機能を実装：

```typescript
// キャッシュからデータを読み込む
const loadFromCache = () => {
  try {
    const cacheKey = getCacheKey();
    const cachedData = localStorage.getItem(cacheKey);
    const cacheTimestamp = localStorage.getItem(getCacheTimestampKey());
    
    if (cachedData && cacheTimestamp) {
      const data = JSON.parse(cachedData);
      const timestamp = new Date(cacheTimestamp);
      const now = new Date();
      const hoursSinceCache = (now.getTime() - timestamp.getTime()) / (1000 * 60 * 60);
      
      // キャッシュが24時間以内なら有効とする
      if (hoursSinceCache < 24) {
        console.log('キャッシュからデータを読み込みました');
        return data;
      }
    }
  } catch (error) {
    console.error('キャッシュ読み込みエラー:', error);
  }
  return null;
};
```

### 4. バックグラウンド更新の実装
キャッシュ読み込み後、最新データをバックグラウンドで取得：

```typescript
// キャッシュ読み込み後、1秒後に最新データを取得（バックグラウンド）
// 無限ループを防ぐため、一度だけ実行
if (!(window as any).dashboardDataRefreshed) {
  (window as any).dashboardDataRefreshed = true;
  setTimeout(() => {
    console.log('キャッシュ読み込み後、最新データを取得します');
    loadSimulations(true);
    // 5秒後にフラグをリセット
    setTimeout(() => {
      (window as any).dashboardDataRefreshed = false;
    }, 5000);
  }, 1000);
}
```

## その他の無限ループパターンと対処法

### 1. setState内でのsetState呼び出し
```typescript
// ❌ 問題のあるコード
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1); // 無限ループ
}, [count]);

// ✅ 修正方法
useEffect(() => {
  // 条件を追加して停止条件を設ける
  if (count < 10) {
    setCount(count + 1);
  }
}, [count]);
```

### 2. 配列やオブジェクトの新規作成
```typescript
// ❌ 問題のあるコード
const options = { key: 'value' }; // 毎回新しいオブジェクト
useEffect(() => {
  // 処理
}, [options]); // 毎回実行される

// ✅ 修正方法1: useMemoを使用
const options = useMemo(() => ({ key: 'value' }), []);

// ✅ 修正方法2: コンポーネント外で定義
const OPTIONS = { key: 'value' };
```

### 3. 関数の依存
```typescript
// ❌ 問題のあるコード
const handleClick = () => { /* 処理 */ };
useEffect(() => {
  // 処理
}, [handleClick]); // 毎回新しい関数なので無限ループ

// ✅ 修正方法: useCallbackを使用
const handleClick = useCallback(() => { /* 処理 */ }, []);
```

## デバッグ方法

### 1. コンソールログでの確認
```typescript
useEffect(() => {
  console.log('Effect実行:', new Date().toISOString());
  // 処理
}, [deps]);
```

### 2. React Developer Toolsの活用
- Componentsタブで再レンダリングの原因を確認
- Profilerタブでパフォーマンスを分析

### 3. 依存配列の確認
```typescript
// 依存配列の値をログ出力
console.log('Dependencies:', { user, authLoading, otherDep });
```

## ベストプラクティス

1. **プリミティブ値を依存配列に使用**
   ```typescript
   // ❌ オブジェクト全体
   useEffect(() => {}, [user]);
   
   // ✅ プリミティブ値
   useEffect(() => {}, [user?.id, user?.email]);
   ```

2. **必要最小限の依存配列**
   - 本当に必要な依存関係のみを含める
   - ESLintのexhaustive-depsルールを活用

3. **条件付き実行**
   ```typescript
   useEffect(() => {
     if (shouldExecute) {
       // 処理
     }
   }, [shouldExecute]);
   ```

4. **クリーンアップ関数の活用**
   ```typescript
   useEffect(() => {
     let isMounted = true;
     
     const fetchData = async () => {
       const data = await getData();
       if (isMounted) {
         setData(data);
       }
     };
     
     fetchData();
     
     return () => {
       isMounted = false;
     };
   }, []);
   ```

## 関連ファイル
- `/workspaces/real-estate-app/bolt_front/src/pages/Dashboard.tsx`
- `/workspaces/real-estate-app/docs_md/02_日報/開発日報_250730_1.md`

## まとめ
無限ループは React 開発で最も一般的な問題の一つです。依存配列の適切な管理と、オブジェクトの参照に関する理解が重要です。問題が発生した場合は、まず依存配列を確認し、必要に応じてプリミティブ値を使用するか、メモ化を活用することで解決できます。