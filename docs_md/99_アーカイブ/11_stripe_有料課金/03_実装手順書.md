# Stripe決済機能 実装手順書

作成日: 2025年8月12日  
バージョン: 1.1.0 (月3回制限版)  
更新日: 2025年8月12日

## 1. 事前準備

### 1.1 Stripeアカウント設定

1. **Stripeアカウント作成**
   - https://stripe.com/jp にアクセス
   - アカウント作成（日本の事業者として登録）

2. **テスト環境設定**
   - ダッシュボードで「テストモード」をON
   - APIキーをメモ（公開可能キー、シークレットキー）

3. **商品・価格の作成**
   ```
   商品名: 大家DX プレミアムプラン
   価格: 2,980円/月
   請求期間: 月額
   通貨: JPY
   無料プラン: 月3回まで利用可能
   ```

### 1.2 Supabase設定

1. **プロジェクト作成**（既存の場合はスキップ）
2. **Edge Functions有効化**
3. **環境変数設定**

## 2. 実装の進め方

### Phase 1: 基盤構築（1日目）

#### 1.1 Stripeセットアップ
- テスト環境設定
- 商品・価格作成（¥2,980/月）
- Webhook設定

#### 1.2 Supabaseデータベース構築

```sql
-- ユーザー利用状況テーブル
CREATE TABLE user_usage (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  usage_count INTEGER DEFAULT 0,
  period_start_date TIMESTAMP DEFAULT NOW(),
  period_end_date TIMESTAMP DEFAULT (NOW() + INTERVAL '30 days'),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

-- サブスクリプション管理テーブル
CREATE TABLE subscriptions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_customer_id TEXT UNIQUE,
  stripe_subscription_id TEXT UNIQUE,
  status TEXT DEFAULT 'inactive',
  current_period_end TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

-- 利用履歴テーブル
CREATE TABLE usage_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  feature_type TEXT NOT NULL,
  feature_data JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- インデックス作成
CREATE INDEX idx_user_usage_user_id ON user_usage(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_usage_history_user_id ON usage_history(user_id);

-- RLS有効化
ALTER TABLE user_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_history ENABLE ROW LEVEL SECURITY;

-- ポリシー設定
CREATE POLICY "Users can view own usage" ON user_usage
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view own subscription" ON subscriptions
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view own history" ON usage_history
  FOR SELECT USING (auth.uid() = user_id);

-- 期間チェック関数（30日ごとの自動リセット）
CREATE OR REPLACE FUNCTION check_and_reset_usage(p_user_id UUID)
RETURNS TABLE(current_count INTEGER, period_end TIMESTAMP) AS $$
DECLARE
  v_usage RECORD;
BEGIN
  SELECT * INTO v_usage FROM user_usage WHERE user_id = p_user_id;
  
  IF NOT FOUND THEN
    INSERT INTO user_usage (user_id)
    VALUES (p_user_id)
    RETURNING usage_count, period_end_date INTO current_count, period_end;
    RETURN NEXT;
    RETURN;
  END IF;
  
  IF v_usage.period_end_date < NOW() THEN
    UPDATE user_usage 
    SET usage_count = 0,
        period_start_date = NOW(),
        period_end_date = NOW() + INTERVAL '30 days',
        updated_at = NOW()
    WHERE user_id = p_user_id
    RETURNING usage_count, period_end_date INTO current_count, period_end;
  ELSE
    current_count := v_usage.usage_count;
    period_end := v_usage.period_end_date;
  END IF;
  
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql;
```

### Phase 2: バックエンド実装（2日目）

#### 2.1 必要なパッケージインストール

```bash
# bolt_frontディレクトリで実行
cd bolt_front
npm install @stripe/stripe-js
```

#### 2.2 環境変数設定

```bash
# .env.local
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_xxxxx
VITE_STRIPE_PRICE_ID=price_xxxxx
```

#### 2.3 使用制限ユーティリティ

`bolt_front/src/utils/usageLimit.ts`:
```typescript
import { supabase } from '../lib/supabase';

interface UsageStatus {
  canUse: boolean;
  currentCount: number;
  limit: number;
  isSubscribed: boolean;
  periodEndDate: Date | null;
  daysLeft: number;
}

export const checkUsageLimit = async (userId: string): Promise<UsageStatus> => {
  // サブスクリプション確認
  const { data: subscription } = await supabase
    .from('subscriptions')
    .select('status')
    .eq('user_id', userId)
    .single();

  if (subscription?.status === 'active') {
    return {
      canUse: true,
      currentCount: 0,
      limit: -1,
      isSubscribed: true,
      periodEndDate: null,
      daysLeft: -1
    };
  }

  // 使用状況確認（自動リセット込み）
  const { data } = await supabase
    .rpc('check_and_reset_usage', { p_user_id: userId });

  const usage = data?.[0] || { current_count: 0, period_end: new Date() };
  const periodEnd = new Date(usage.period_end);
  const daysLeft = Math.ceil((periodEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

  return {
    canUse: usage.current_count < 3,  // 月3回制限
    currentCount: usage.current_count,
    limit: 3,
    isSubscribed: false,
    periodEndDate: periodEnd,
    daysLeft: Math.max(0, daysLeft)
  };
};

export const incrementUsage = async (userId: string, featureType: string) => {
  // 履歴記録
  await supabase.from('usage_history').insert({
    user_id: userId,
    feature_type: featureType,
    feature_data: { timestamp: new Date().toISOString() }
  });

  // カウントアップ
  const { data } = await supabase
    .from('user_usage')
    .select('usage_count')
    .eq('user_id', userId)
    .single();

  const newCount = (data?.usage_count || 0) + 1;

  await supabase
    .from('user_usage')
    .update({ 
      usage_count: newCount,
      updated_at: new Date().toISOString()
    })
    .eq('user_id', userId);

  return newCount;
};
```

#### 2.4 Supabase Edge Functions

```bash
supabase functions new create-checkout-session
```

`supabase/functions/create-checkout-session/index.ts`:
```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import Stripe from 'https://esm.sh/stripe@12.0.0?target=deno';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1';

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY')!, {
  apiVersion: '2023-10-16',
});

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

serve(async (req) => {
  try {
    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    
    // ユーザー認証
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Stripeカスタマー作成/取得
    let customerId;
    const { data: sub } = await supabase
      .from('subscriptions')
      .select('stripe_customer_id')
      .eq('user_id', user.id)
      .single();

    if (sub?.stripe_customer_id) {
      customerId = sub.stripe_customer_id;
    } else {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: { user_id: user.id }
      });
      customerId = customer.id;

      await supabase.from('subscriptions').upsert({
        user_id: user.id,
        stripe_customer_id: customerId
      });
    }

    // Checkout Session作成
    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [{
        price: Deno.env.get('STRIPE_PRICE_ID')!,
        quantity: 1
      }],
      mode: 'subscription',
      success_url: `${req.headers.get('origin')}/payment-success`,
      cancel_url: `${req.headers.get('origin')}/`,
    });

    return new Response(JSON.stringify({ sessionId: session.id }), {
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }
});
```

### Phase 3: フロントエンド実装（3-4日目）

#### 3.1 使用状況表示コンポーネント

`bolt_front/src/components/UsageStatus.tsx`:
```typescript
import React, { useEffect, useState } from 'react';
import { useAuthContext } from './AuthProvider';
import { checkUsageLimit } from '../utils/usageLimit';
import { Calendar, AlertCircle } from 'lucide-react';

export const UsageStatus: React.FC = () => {
  const { user } = useAuthContext();
  const [usage, setUsage] = useState<any>(null);

  useEffect(() => {
    if (user) {
      loadUsage();
    }
  }, [user]);

  const loadUsage = async () => {
    if (!user) return;
    const status = await checkUsageLimit(user.id);
    setUsage(status);
  };

  if (!usage || usage.isSubscribed) return null;

  const remainingCount = usage.limit - usage.currentCount;
  const isWarning = remainingCount <= 1;
  const isError = remainingCount === 0;

  return (
    <div className={`p-3 rounded-lg border ${
      isError ? 'bg-red-50 border-red-200' :
      isWarning ? 'bg-yellow-50 border-yellow-200' :
      'bg-blue-50 border-blue-200'
    }`}>
      <div className="flex items-start gap-2">
        <AlertCircle className={`h-5 w-5 mt-0.5 ${
          isError ? 'text-red-500' :
          isWarning ? 'text-yellow-500' :
          'text-blue-500'
        }`} />
        <div className="flex-1">
          <p className={`text-sm font-medium ${
            isError ? 'text-red-800' :
            isWarning ? 'text-yellow-800' :
            'text-blue-800'
          }`}>
            {isError 
              ? '無料利用枠を使い切りました'
              : `今月の利用可能回数: ${remainingCount}/${usage.limit}回`
            }
          </p>
          <div className="flex items-center gap-1 mt-1">
            <Calendar className="h-3 w-3 text-gray-500" />
            <p className="text-xs text-gray-600">
              次回リセット: {usage.periodEndDate?.toLocaleDateString('ja-JP')} 
              （あと{usage.daysLeft}日）
            </p>
          </div>
          {(isWarning || isError) && (
            <button className="text-xs text-blue-600 hover:text-blue-700 font-medium mt-2">
              プレミアムプランにアップグレード →
            </button>
          )}
        </div>
      </div>
    </div>
  );
};
```

#### 3.2 シミュレーター実行ボタン

`bolt_front/src/components/SimulatorExecuteButton.tsx`:
```typescript
import React, { useState } from 'react';
import { useAuthContext } from './AuthProvider';
import { checkUsageLimit, incrementUsage } from '../utils/usageLimit';
import { PlayCircle, Lock, Star, Loader2 } from 'lucide-react';
import { UpgradeModal } from './UpgradeModal';

export const SimulatorExecuteButton: React.FC<{ onExecute: () => void }> = ({ onExecute }) => {
  const { user } = useAuthContext();
  const [usage, setUsage] = useState<any>(null);
  const [showUpgradeModal, setShowUpgradeModal] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (user) {
      loadUsage();
    }
  }, [user]);

  const loadUsage = async () => {
    const status = await checkUsageLimit(user.id);
    setUsage(status);
  };

  const handleClick = async () => {
    if (!usage.canUse && !usage.isSubscribed) {
      setShowUpgradeModal(true);
      return;
    }

    setIsLoading(true);
    await onExecute();
    
    if (!usage.isSubscribed) {
      await incrementUsage(user.id, 'simulator');
      await loadUsage();
    }
    setIsLoading(false);
  };

  // プレミアム会員
  if (usage?.isSubscribed) {
    return (
      <button
        onClick={handleClick}
        disabled={isLoading}
        className="w-full px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 
                 text-white font-medium rounded-lg hover:opacity-90
                 disabled:opacity-50 disabled:cursor-not-allowed
                 flex items-center justify-center gap-2"
      >
        {isLoading ? (
          <Loader2 className="h-5 w-5 animate-spin" />
        ) : (
          <>
            <Star className="h-5 w-5" />
            <span>シミュレーション実行</span>
          </>
        )}
      </button>
    );
  }

  // 無料プラン（利用可能）
  if (usage?.canUse) {
    return (
      <>
        <button
          onClick={handleClick}
          disabled={isLoading}
          className="w-full px-6 py-3 bg-blue-600 text-white font-medium 
                   rounded-lg hover:bg-blue-700 disabled:opacity-50
                   flex items-center justify-center gap-2"
        >
          {isLoading ? (
            <Loader2 className="h-5 w-5 animate-spin" />
          ) : (
            <>
              <PlayCircle className="h-5 w-5" />
              <span>シミュレーション実行</span>
              <span className="text-xs opacity-80">
                （残り{usage.limit - usage.currentCount}回）
              </span>
            </>
          )}
        </button>
        
        {/* 残り回数が少ない場合の注意表示 */}
        {usage.limit - usage.currentCount <= 1 && (
          <p className="mt-2 text-xs text-gray-500 text-center">
            💡 プレミアムプランで無制限利用が可能です
          </p>
        )}
      </>
    );
  }

  // 無料プラン（制限到達）
  return (
    <>
      <button
        onClick={() => setShowUpgradeModal(true)}
        className="w-full px-6 py-3 bg-gray-400 text-white font-medium 
                 rounded-lg cursor-not-allowed flex items-center 
                 justify-center gap-2"
      >
        <Lock className="h-5 w-5" />
        <span>利用制限に到達</span>
      </button>
      
      <UpgradeModal 
        isOpen={showUpgradeModal}
        onClose={() => setShowUpgradeModal(false)}
      />
    </>
  );
};
```

### Phase 4: テスト・調整（5日目）

#### 4.1 ローカルテスト

1. **テストユーザー作成**
2. **シミュレーター3回実行**
3. **4回目で制限画面表示確認**
4. **Stripeテストカードで決済**
   - カード番号: 4242 4242 4242 4242
   - 有効期限: 任意の未来日付
   - CVC: 任意の3桁

#### 4.2 エラー処理確認

- ネットワークエラー
- 決済失敗
- Webhook失敗

### Phase 5: 本番リリース（6日目）

1. **Stripe本番キー設定**
2. **環境変数更新**
3. **Edge Functionsデプロイ**
4. **フロントエンドビルド・デプロイ**

## 3. チェックリスト

### 開発完了確認

- [ ] データベーステーブル作成
- [ ] RLS設定
- [ ] 月3回制限機能実装
- [ ] アップグレード画面実装
- [ ] Stripe Checkout統合
- [ ] Webhook処理実装
- [ ] 30日ごとの自動リセット動作確認
- [ ] エラーハンドリング

### セキュリティ確認

- [ ] APIキーが環境変数で管理
- [ ] Webhook署名検証
- [ ] ユーザー認証チェック
- [ ] SQLインジェクション対策

### 法的要件確認

- [ ] 特定商取引法表記
- [ ] 返金ポリシー明記
- [ ] 利用規約更新
- [ ] プライバシーポリシー更新

## 4. トラブルシューティング

### よくある問題と解決方法

| 問題 | 原因 | 解決方法 |
|------|------|----------|
| 決済画面が表示されない | Stripeキーの設定ミス | 環境変数を確認 |
| Webhookが動作しない | エンドポイントURL間違い | Stripeダッシュボードで確認 |
| 使用回数がリセットされない | 期間計算のバグ | check_and_reset_usage関数を確認 |
| RLSエラー | ポリシー設定ミス | Supabaseダッシュボードで確認 |
| 3回制限が効かない | カウント処理の不具合 | incrementUsage関数を確認 |

## 5. 運用手順

### 月次確認項目

1. **売上確認**
   - Stripeダッシュボードで確認
   - MRR計算

2. **使用状況分析**
   - 無料枠（3回）使い切り率
   - コンバージョン率（目標10-15%）

3. **エラー監視**
   - 決済失敗率
   - Webhookエラー

### 顧客対応

1. **決済失敗時**
   - カード有効期限切れ通知
   - 別の決済方法案内

2. **解約時**
   - 解約理由ヒアリング
   - 再開案内

## 6. 重要な実装ポイント

### 6.1 カウント対象の明確化
```typescript
// カウントする操作
- ✅ 新規シミュレーション実行
- ✅ 新規分析実行（今後実装）

// カウントしない操作
- ❌ 過去の結果閲覧
- ❌ PDFダウンロード（既存データ）
- ❌ プロフィール編集
- ❌ ログイン/ログアウト
```

### 6.2 エッジケースの処理
```typescript
// 期間終了日をまたぐ処理
if (usage.periodEndDate < new Date()) {
  // 自動リセット処理
  await resetUsageCount(userId);
}

// 決済失敗時の処理
if (paymentFailed) {
  // 3日間の猶予期間
  await setGracePeriod(userId, 3);
}
```

### 6.3 パフォーマンス考慮
```typescript
// 使用状況のキャッシュ（5分間）
const CACHE_DURATION = 5 * 60 * 1000;
let cachedUsage = null;
let cacheTime = null;

if (cachedUsage && Date.now() - cacheTime < CACHE_DURATION) {
  return cachedUsage;
}
```

---

**次のステップ**: この手順書に従って実装を進め、完了後は運用マニュアルで日々の運用を確認