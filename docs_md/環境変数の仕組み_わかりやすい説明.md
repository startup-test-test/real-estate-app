# 環境変数の仕組み - わかりやすい説明

## 🤔 なぜ環境変数の扱いが複雑なのか？

### 1. Codespaces（開発環境）の場合
```
[GitHub Secrets] → [Codespace起動] → [環境変数として利用可能]
```
- **動的に読み込める**（リアルタイムで値を取得）
- 例：`process.env.VITE_API_URL`で直接アクセス可能

### 2. Xserver（本番環境）の場合
```
[ビルド時に.envファイル読込] → [JavaScriptに埋め込み] → [静的ファイルとして配信]
```
- **ビルド時に固定される**（後から変更不可）
- 静的ホスティングなので、サーバー側の環境変数は存在しない

## 📝 具体的な例

### ビルド前のコード
```javascript
const apiUrl = import.meta.env.VITE_API_URL;
// 開発時：環境変数から動的に取得
// ビルド時：.env.productionの値に置換
```

### ビルド後のコード（実際にXserverに配置されるもの）
```javascript
const apiUrl = "https://real-estate-app-1-iii4.onrender.com";
// 文字列として埋め込まれている！
```

## 🔑 重要なポイント

### 1. **公開しても安全な情報のみ**
- ✅ API URL（エンドポイント）
- ✅ Supabase URL
- ✅ Supabase anon key（RLSで保護されている）
- ❌ 秘密のAPIキー
- ❌ データベースのパスワード

### 2. **ビルドコマンドが環境を決定**
```bash
npm run build          # .env.productionを使用
npm run build:dev      # .env.developmentを使用
npm run dev            # Codespace環境変数を使用
```

### 3. **実際の運用フロー**

#### 開発時（Codespace）
1. Codespace Secretsに設定
2. 自動的に環境変数として利用可能
3. コード変更なしで値を変更可能

#### 本番デプロイ時（Xserver）
1. `.env.production`に本番用の値を設定
2. `npm run build`でビルド
3. ビルド済みファイルをXserverにアップロード
4. **値はJavaScriptファイルに埋め込まれている**

## 🎯 まとめ

- **Codespace**: サーバーがあるので環境変数が使える
- **Xserver**: 静的ファイルのみなので、ビルド時に値を埋め込む必要がある
- **セキュリティ**: 公開される前提で.envファイルを作成する

これが「なぜXserverでは環境変数が読めないのか」の答えです！

---
作成日: 2025年7月27日