# ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆæ›¸

**ä½œæˆæ—¥**: 2025å¹´8æœˆ14æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0.0  
**ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: Supabase PostgreSQL  
**å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **: å¤§å®¶DX ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³èª²é‡‘ã‚·ã‚¹ãƒ†ãƒ 

---

## ğŸ“‹ æ¦‚è¦

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€å¤§å®¶DXã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã®åŒ…æ‹¬çš„ãªã‚¬ã‚¤ãƒ‰ã§ã™ã€‚Stripeæ±ºæ¸ˆã‚·ã‚¹ãƒ†ãƒ ã¨ã®é€£æºã€ä½¿ç”¨åˆ¶é™ç®¡ç†ã€RLSï¼ˆRow Level Securityï¼‰ã«ã‚ˆã‚‹å³æ ¼ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…ã«ã¤ã„ã¦è©³è¿°ã—ã¾ã™ã€‚

### ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶
- æœˆé¡èª²é‡‘ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2,980å††/æœˆï¼‰
- ä½¿ç”¨åˆ¶é™ç®¡ç†ï¼ˆç„¡æ–™ï¼š5å›/30æ—¥ã€æœ‰æ–™ï¼šç„¡åˆ¶é™ï¼‰
- ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³è§£ç´„ãƒ»å†é–‹æ©Ÿèƒ½
- äºŒé‡æ±ºæ¸ˆé˜²æ­¢ã‚·ã‚¹ãƒ†ãƒ 
- åˆ©ç”¨å±¥æ­´ãƒ»åˆ†ææ©Ÿèƒ½

---

## ğŸ—ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“æ§‹æˆ

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Supabase Auth             â”‚
â”‚        (ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã‚·ã‚¹ãƒ†ãƒ )        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†         â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚Subscriptionsâ”‚ User Usage  â”‚    â”‚
â”‚    â”‚  æ±ºæ¸ˆæƒ…å ±   â”‚  åˆ©ç”¨åˆ¶é™   â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        åˆ©ç”¨å±¥æ­´ãƒ»åˆ†æã‚·ã‚¹ãƒ†ãƒ        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚Usage Historyâ”‚  Analytics  â”‚    â”‚
â”‚    â”‚  å±¥æ­´ç®¡ç†   â”‚   åˆ†ææ©Ÿèƒ½   â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹æˆä¸€è¦§

### 1. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ†ãƒ¼ãƒ–ãƒ«å | ç”¨é€” | ä¸»è¦æ©Ÿèƒ½ |
|-----------|------|----------|
| `subscriptions` | Stripeé€£æºãƒ»èª²é‡‘ç®¡ç† | æ±ºæ¸ˆçŠ¶æ…‹ã€æœŸé–“ç®¡ç†ã€è§£ç´„å‡¦ç† |
| `user_usage` | åˆ©ç”¨åˆ¶é™ç®¡ç† | ç„¡æ–™æ åˆ¶é™ã€æœŸé–“ãƒªã‚»ãƒƒãƒˆ |
| `usage_history` | åˆ©ç”¨å±¥æ­´è¨˜éŒ² | æ©Ÿèƒ½åˆ¥åˆ©ç”¨çµ±è¨ˆã€åˆ†æãƒ‡ãƒ¼ã‚¿ |

### 2. æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ é€£æºãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ†ãƒ¼ãƒ–ãƒ«å | ç”¨é€” | é€£æºå†…å®¹ |
|-----------|------|----------|
| `auth.users` | ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ | Supabase Authé€£æº |
| `properties` | ç‰©ä»¶ç®¡ç† | ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¯¾è±¡ |
| `simulations` | è¨ˆç®—çµæœä¿å­˜ | åˆ©ç”¨ã‚«ã‚¦ãƒ³ãƒˆå¯¾è±¡ |
| `market_analyses` | å¸‚å ´åˆ†æ | åˆ©ç”¨ã‚«ã‚¦ãƒ³ãƒˆå¯¾è±¡ |

---

## ğŸ“ ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°è¨­è¨ˆ

### 1. subscriptions ãƒ†ãƒ¼ãƒ–ãƒ«

**ç›®çš„**: Stripeã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã¨ã®åŒæœŸãƒ»èª²é‡‘çŠ¶æ…‹ç®¡ç†

```sql
CREATE TABLE subscriptions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
  stripe_customer_id TEXT UNIQUE,
  stripe_subscription_id TEXT UNIQUE,
  status TEXT DEFAULT 'inactive' NOT NULL,
  current_period_start TIMESTAMP WITH TIME ZONE,
  current_period_end TIMESTAMP WITH TIME ZONE,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  cancel_at TIMESTAMP WITH TIME ZONE,
  cancellation_reason TEXT,
  cancellation_feedback TEXT,
  cancelled_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
```

#### ã‚«ãƒ©ãƒ è©³ç´°

| ã‚«ãƒ©ãƒ å | å‹ | åˆ¶ç´„ | èª¬æ˜ |
|---------|-----|------|------|
| `id` | UUID | PRIMARY KEY | ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ä¸€æ„è­˜åˆ¥å­ |
| `user_id` | UUID | UNIQUE, NOT NULL, FK | ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆauth.users.idï¼‰ |
| `stripe_customer_id` | TEXT | UNIQUE | Stripeé¡§å®¢ID |
| `stripe_subscription_id` | TEXT | UNIQUE | Stripeã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ID |
| `status` | TEXT | NOT NULL | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆactive/canceled/past_due/inactiveï¼‰ |
| `current_period_start` | TIMESTAMPTZ | | ç¾åœ¨ã®èª²é‡‘æœŸé–“é–‹å§‹æ—¥ |
| `current_period_end` | TIMESTAMPTZ | | ç¾åœ¨ã®èª²é‡‘æœŸé–“çµ‚äº†æ—¥ |
| `cancel_at_period_end` | BOOLEAN | DEFAULT FALSE | æœŸé–“çµ‚äº†æ™‚è§£ç´„ãƒ•ãƒ©ã‚° |
| `cancel_at` | TIMESTAMPTZ | | è§£ç´„äºˆå®šæ—¥æ™‚ |
| `cancellation_reason` | TEXT | | è§£ç´„ç†ç”± |
| `cancellation_feedback` | TEXT | | è§£ç´„æ™‚ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ |
| `cancelled_at` | TIMESTAMPTZ | | å®Ÿéš›ã®è§£ç´„æ—¥æ™‚ |

#### ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å€¤å®šç¾©

| statuså€¤ | èª¬æ˜ | åˆ©ç”¨æ¨©é™ |
|----------|------|----------|
| `active` | æœ‰åŠ¹ãªãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡ | ç„¡åˆ¶é™åˆ©ç”¨å¯èƒ½ |
| `canceled` | è§£ç´„æ¸ˆã¿ | ç„¡æ–™æ ã®ã¿ |
| `past_due` | æ”¯æ‰•ã„é…å»¶ | åˆ¶é™ä»˜ãåˆ©ç”¨ |
| `inactive` | æœªåŠ å…¥ | ç„¡æ–™æ ã®ã¿ |

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

```sql
-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_stripe_customer_id ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_period_end ON subscriptions(current_period_end);
CREATE INDEX idx_subscriptions_cancel_at ON subscriptions(cancel_at);
```

---

### 2. user_usage ãƒ†ãƒ¼ãƒ–ãƒ«

**ç›®çš„**: ç„¡æ–™ãƒ—ãƒ©ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åˆ©ç”¨åˆ¶é™ç®¡ç†ãƒ»æœŸé–“ãƒªã‚»ãƒƒãƒˆ

```sql
CREATE TABLE user_usage (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
  usage_count INTEGER DEFAULT 0 NOT NULL,
  period_start_date TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  period_end_date TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '30 days') NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
```

#### ã‚«ãƒ©ãƒ è©³ç´°

| ã‚«ãƒ©ãƒ å | å‹ | åˆ¶ç´„ | èª¬æ˜ |
|---------|-----|------|------|
| `id` | UUID | PRIMARY KEY | åˆ©ç”¨è¨˜éŒ²ã®ä¸€æ„è­˜åˆ¥å­ |
| `user_id` | UUID | UNIQUE, NOT NULL, FK | ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆauth.users.idï¼‰ |
| `usage_count` | INTEGER | DEFAULT 0 | ç¾åœ¨ã®æœŸé–“å†…åˆ©ç”¨å›æ•° |
| `period_start_date` | TIMESTAMPTZ | NOT NULL | ç¾åœ¨ã®åˆ©ç”¨æœŸé–“é–‹å§‹æ—¥ |
| `period_end_date` | TIMESTAMPTZ | NOT NULL | æœŸé–“çµ‚äº†æ—¥ï¼ˆ30æ—¥å¾Œï¼‰ |

#### åˆ©ç”¨åˆ¶é™ä»•æ§˜

```typescript
// åˆ©ç”¨åˆ¶é™å®šæ•°
const USAGE_LIMITS = {
  FREE_PLAN: 5,        // ç„¡æ–™ãƒ—ãƒ©ãƒ³ï¼šæœˆ5å›
  PREMIUM_PLAN: -1,    // ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ï¼šç„¡åˆ¶é™ï¼ˆ-1ã§è¡¨ç¾ï¼‰
  PERIOD_DAYS: 30      // ãƒªã‚»ãƒƒãƒˆæœŸé–“ï¼š30æ—¥
};
```

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

```sql
-- é«˜é€Ÿæ¤œç´¢ç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_user_usage_user_id ON user_usage(user_id);
CREATE INDEX idx_user_usage_period_end ON user_usage(period_end_date);
CREATE INDEX idx_user_usage_updated_at ON user_usage(updated_at);
```

---

### 3. usage_history ãƒ†ãƒ¼ãƒ–ãƒ«

**ç›®çš„**: æ©Ÿèƒ½åˆ©ç”¨å±¥æ­´ã®è©³ç´°è¨˜éŒ²ãƒ»åˆ†æãƒ‡ãƒ¼ã‚¿åé›†

```sql
CREATE TABLE usage_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  feature_type TEXT NOT NULL,
  feature_data JSONB DEFAULT '{}',
  session_id TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
```

#### ã‚«ãƒ©ãƒ è©³ç´°

| ã‚«ãƒ©ãƒ å | å‹ | åˆ¶ç´„ | èª¬æ˜ |
|---------|-----|------|------|
| `id` | UUID | PRIMARY KEY |å±¥æ­´ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ä¸€æ„è­˜åˆ¥å­ |
| `user_id` | UUID | NOT NULL, FK | ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆauth.users.idï¼‰ |
| `feature_type` | TEXT | NOT NULL | æ©Ÿèƒ½ç¨®åˆ¥ï¼ˆsimulator/market_analysisç­‰ï¼‰ |
| `feature_data` | JSONB | DEFAULT '{}' | åˆ©ç”¨è©³ç´°ãƒ‡ãƒ¼ã‚¿ï¼ˆJSONå½¢å¼ï¼‰ |
| `session_id` | TEXT | | ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ç”¨ï¼‰ |
| `ip_address` | INET | | ã‚¢ã‚¯ã‚»ã‚¹å…ƒIPã‚¢ãƒ‰ãƒ¬ã‚¹ |
| `user_agent` | TEXT | | ãƒ–ãƒ©ã‚¦ã‚¶ãƒ»ãƒ‡ãƒã‚¤ã‚¹æƒ…å ± |

#### æ©Ÿèƒ½ç¨®åˆ¥å®šç¾©

| feature_type | èª¬æ˜ | ã‚«ã‚¦ãƒ³ãƒˆå¯¾è±¡ |
|--------------|------|--------------|
| `simulator` | æŠ•è³‡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | âœ… |
| `market_analysis` | å¸‚å ´åˆ†æ | âœ… |
| `property_share` | ç‰©ä»¶å…±æœ‰ | âŒ |
| `comment` | ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ | âŒ |
| `profile_update` | ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æ›´æ–° | âŒ |

#### feature_dataæ§‹é€ ä¾‹

```json
{
  "simulation_id": "uuid",
  "property_id": "uuid", 
  "calculation_type": "roi",
  "input_values": {
    "purchase_price": 50000000,
    "monthly_rent": 200000
  },
  "execution_time_ms": 1250
}
```

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

```sql
-- åˆ†æãƒ»ãƒ¬ãƒãƒ¼ãƒˆç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_usage_history_user_id ON usage_history(user_id);
CREATE INDEX idx_usage_history_feature_type ON usage_history(feature_type);
CREATE INDEX idx_usage_history_created_at ON usage_history(created_at DESC);
CREATE INDEX idx_usage_history_session_id ON usage_history(session_id);

-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé«˜é€Ÿé›†è¨ˆç”¨ï¼‰
CREATE INDEX idx_usage_history_user_feature_date 
  ON usage_history(user_id, feature_type, created_at DESC);
```

---

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆï¼ˆRLSï¼‰

### Row Level Security å…¨ä½“è¨­è¨ˆ

ã™ã¹ã¦ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³é–¢é€£ãƒ†ãƒ¼ãƒ–ãƒ«ã§RLSã‚’æœ‰åŠ¹åŒ–ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã™ã€‚

```sql
-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_history ENABLE ROW LEVEL SECURITY;
```

### 1. subscriptions ãƒ†ãƒ¼ãƒ–ãƒ« RLSãƒãƒªã‚·ãƒ¼

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã®ã¿é–²è¦§ãƒ»æ›´æ–°å¯èƒ½
CREATE POLICY "Users can view own subscription" ON subscriptions
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own subscription" ON subscriptions
  FOR UPDATE USING (auth.uid() = user_id);

-- æ–°è¦ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ãƒ»Webhookå°‚ç”¨ï¼‰
CREATE POLICY "Service role can insert subscriptions" ON subscriptions
  FOR INSERT WITH CHECK (auth.role() = 'service_role');

-- Webhookãƒ»ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«å°‚ç”¨æ›´æ–°
CREATE POLICY "Service role can update subscriptions" ON subscriptions
  FOR UPDATE USING (auth.role() = 'service_role');
```

### 2. user_usage ãƒ†ãƒ¼ãƒ–ãƒ« RLSãƒãƒªã‚·ãƒ¼

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®åˆ©ç”¨çŠ¶æ³ã®ã¿å‚ç…§ãƒ»æ›´æ–°å¯èƒ½
CREATE POLICY "Users can view own usage" ON user_usage
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own usage" ON user_usage
  FOR UPDATE USING (auth.uid() = user_id);

-- è‡ªå‹•ä½œæˆï¼ˆåˆå›åˆ©ç”¨æ™‚ï¼‰
CREATE POLICY "Users can insert own usage" ON user_usage
  FOR INSERT WITH CHECK (auth.uid() = user_id);
```

### 3. usage_history ãƒ†ãƒ¼ãƒ–ãƒ« RLSãƒãƒªã‚·ãƒ¼

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®å±¥æ­´ã®ã¿é–²è¦§å¯èƒ½
CREATE POLICY "Users can view own history" ON usage_history
  FOR SELECT USING (auth.uid() = user_id);

-- å±¥æ­´è¨˜éŒ²ï¼ˆã‚·ã‚¹ãƒ†ãƒ å´ã§ã®è‡ªå‹•è¨˜éŒ²ï¼‰
CREATE POLICY "Authenticated users can insert history" ON usage_history
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- ç®¡ç†è€…ãƒ»åˆ†æç”¨ï¼ˆã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ï¼‰
CREATE POLICY "Service role can view all history" ON usage_history
  FOR SELECT USING (auth.role() = 'service_role');
```

---

## ğŸ”§ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢æ•°ãƒ»ãƒˆãƒªã‚¬ãƒ¼

### 1. åˆ©ç”¨æœŸé–“ãƒã‚§ãƒƒã‚¯ãƒ»ãƒªã‚»ãƒƒãƒˆé–¢æ•°

```sql
CREATE OR REPLACE FUNCTION check_and_reset_usage(p_user_id UUID)
RETURNS TABLE(current_count INTEGER, period_end TIMESTAMP WITH TIME ZONE) AS $$
DECLARE
  v_usage RECORD;
BEGIN
  -- ç¾åœ¨ã®ä½¿ç”¨çŠ¶æ³ã‚’å–å¾—
  SELECT * INTO v_usage FROM user_usage WHERE user_id = p_user_id;
  
  -- ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
  IF NOT FOUND THEN
    INSERT INTO user_usage (user_id, usage_count, period_start_date, period_end_date)
    VALUES (p_user_id, 0, NOW(), NOW() + INTERVAL '30 days')
    RETURNING usage_count, period_end_date INTO current_count, period_end;
    RETURN NEXT;
    RETURN;
  END IF;
  
  -- æœŸé–“ãŒéãã¦ã„ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
  IF v_usage.period_end_date < NOW() THEN
    UPDATE user_usage 
    SET usage_count = 0,
        period_start_date = NOW(),
        period_end_date = NOW() + INTERVAL '30 days',
        updated_at = NOW()
    WHERE user_id = p_user_id
    RETURNING usage_count, period_end_date INTO current_count, period_end;
  ELSE
    current_count := v_usage.usage_count;
    period_end := v_usage.period_end_date;
  END IF;
  
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 2. ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡ãƒã‚§ãƒƒã‚¯é–¢æ•°

```sql
CREATE OR REPLACE FUNCTION is_premium_user(p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_status TEXT;
BEGIN
  SELECT status INTO v_status 
  FROM subscriptions 
  WHERE user_id = p_user_id;
  
  RETURN COALESCE(v_status = 'active', FALSE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3. åˆ©ç”¨åˆ¶é™ãƒã‚§ãƒƒã‚¯é–¢æ•°

```sql
CREATE OR REPLACE FUNCTION can_use_feature(p_user_id UUID, p_feature_type TEXT)
RETURNS TABLE(
  can_use BOOLEAN, 
  current_count INTEGER, 
  limit_count INTEGER,
  is_premium BOOLEAN,
  period_end TIMESTAMP WITH TIME ZONE
) AS $$
DECLARE
  v_is_premium BOOLEAN;
  v_usage_result RECORD;
BEGIN
  -- ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡ãƒã‚§ãƒƒã‚¯
  SELECT is_premium_user(p_user_id) INTO v_is_premium;
  
  -- ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡ã¯ç„¡åˆ¶é™
  IF v_is_premium THEN
    SELECT TRUE, 0, -1, TRUE, NULL 
    INTO can_use, current_count, limit_count, is_premium, period_end;
    RETURN NEXT;
    RETURN;
  END IF;
  
  -- ç„¡æ–™ãƒ—ãƒ©ãƒ³ã®åˆ¶é™ãƒã‚§ãƒƒã‚¯
  SELECT * INTO v_usage_result FROM check_and_reset_usage(p_user_id);
  
  SELECT 
    (v_usage_result.current_count < 5), 
    v_usage_result.current_count,
    5,
    FALSE,
    v_usage_result.period_end
  INTO can_use, current_count, limit_count, is_premium, period_end;
  
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 4. è‡ªå‹•æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼

```sql
-- updated_atè‡ªå‹•æ›´æ–°é–¢æ•°
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- subscriptionsãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ãƒˆãƒªã‚¬ãƒ¼
CREATE TRIGGER update_subscriptions_updated_at 
  BEFORE UPDATE ON subscriptions
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();

-- user_usageãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ãƒˆãƒªã‚¬ãƒ¼
CREATE TRIGGER update_user_usage_updated_at 
  BEFORE UPDATE ON user_usage
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();
```

---

## ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãƒ»ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

### 1. æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant App as ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
    participant Supabase as Supabase
    participant Stripe as Stripe
    
    User->>App: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    App->>Supabase: auth.signUp()
    Supabase->>App: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆå®Œäº†
    Note over App,Supabase: user_usageåˆæœŸåŒ–ã¯åˆå›åˆ©ç”¨æ™‚ã«è‡ªå‹•å®Ÿè¡Œ
    User->>App: åˆå›æ©Ÿèƒ½åˆ©ç”¨
    App->>Supabase: can_use_feature() å®Ÿè¡Œ
    Supabase->>Supabase: user_usageè‡ªå‹•ä½œæˆ
    Supabase->>App: åˆ©ç”¨å¯èƒ½(4/5)
```

### 2. ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant App as ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
    participant Edge as Edge Function
    participant Stripe as Stripe
    participant Webhook as Stripe Webhook
    participant DB as Supabase DB
    
    User->>App: ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
    App->>Edge: create-checkout-session
    Edge->>Stripe: checkout.sessions.create
    Stripe->>App: ã‚»ãƒƒã‚·ãƒ§ãƒ³URL
    App->>Stripe: æ±ºæ¸ˆãƒšãƒ¼ã‚¸é·ç§»
    Stripe->>User: æ±ºæ¸ˆå®Œäº†
    Stripe->>Webhook: subscription.created
    Webhook->>DB: subscriptionsæ›´æ–°
    DB->>App: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥
    App->>User: ãƒ—ãƒ¬ãƒŸã‚¢ãƒ æ©Ÿèƒ½æœ‰åŠ¹
```

### 3. åˆ©ç”¨åˆ¶é™ãƒã‚§ãƒƒã‚¯ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant App as ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
    participant DB as Supabase DB
    
    User->>App: æ©Ÿèƒ½åˆ©ç”¨è¦æ±‚
    App->>DB: can_use_feature(user_id, 'simulator')
    DB->>DB: ãƒ—ãƒ¬ãƒŸã‚¢ãƒ çŠ¶æ…‹ç¢ºèª
    alt ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡
        DB->>App: åˆ©ç”¨å¯èƒ½(ç„¡åˆ¶é™)
        App->>User: æ©Ÿèƒ½å®Ÿè¡Œ
    else ç„¡æ–™ãƒ—ãƒ©ãƒ³
        DB->>DB: æœŸé–“ãƒ»å›æ•°ãƒã‚§ãƒƒã‚¯
        alt åˆ¶é™å†…
            DB->>App: åˆ©ç”¨å¯èƒ½(3/5)
            App->>User: æ©Ÿèƒ½å®Ÿè¡Œ
            App->>DB: usage_count + 1
        else åˆ¶é™è¶…é
            DB->>App: åˆ©ç”¨ä¸å¯(5/5)
            App->>User: ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
        end
    end
```

### 4. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³è§£ç´„ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant App as ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
    participant Edge as Edge Function
    participant Stripe as Stripe
    participant DB as Supabase DB
    
    User->>App: è§£ç´„ãƒœã‚¿ãƒ³
    App->>App: è§£ç´„ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
    User->>App: è§£ç´„ç¢ºå®š
    App->>Edge: cancel-subscription
    Edge->>Stripe: subscription.update(cancel_at_period_end: true)
    Stripe->>Edge: è§£ç´„äºˆå®šè¨­å®šå®Œäº†
    Edge->>DB: subscriptionsæ›´æ–°(cancel_atè¨­å®š)
    DB->>App: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
    App->>User: è§£ç´„äºˆå®šé€šçŸ¥ï¼ˆæ®‹ã‚Š30æ—¥ï¼‰
    
    Note over User,DB: æœŸé–“çµ‚äº†æ™‚ã«è‡ªå‹•ã§ inactive ã«å¤‰æ›´
```

---

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ»ãƒ¬ãƒãƒ¼ãƒˆè¨­è¨ˆ

### 1. åˆ©ç”¨çµ±è¨ˆãƒ“ãƒ¥ãƒ¼

```sql
-- æœˆé–“åˆ©ç”¨çµ±è¨ˆãƒ“ãƒ¥ãƒ¼
CREATE VIEW monthly_usage_stats AS
SELECT 
  DATE_TRUNC('month', created_at) as month,
  feature_type,
  COUNT(*) as usage_count,
  COUNT(DISTINCT user_id) as unique_users
FROM usage_history 
GROUP BY DATE_TRUNC('month', created_at), feature_type
ORDER BY month DESC, usage_count DESC;

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¥åˆ©ç”¨ã‚µãƒãƒªãƒ¼ãƒ“ãƒ¥ãƒ¼  
CREATE VIEW user_usage_summary AS
SELECT 
  u.user_id,
  u.usage_count as current_period_count,
  u.period_end_date,
  s.status as subscription_status,
  CASE WHEN s.status = 'active' THEN 'unlimited' 
       ELSE (5 - u.usage_count)::TEXT END as remaining_uses
FROM user_usage u
LEFT JOIN subscriptions s ON u.user_id = s.user_id;
```

### 2. åç›Šåˆ†æã‚¯ã‚¨ãƒª

```sql
-- æœˆé–“åç›Šãƒ¬ãƒãƒ¼ãƒˆ
SELECT 
  DATE_TRUNC('month', current_period_start) as month,
  COUNT(*) as active_subscriptions,
  COUNT(*) * 2980 as monthly_revenue,
  COUNT(CASE WHEN cancel_at_period_end THEN 1 END) as canceling_users
FROM subscriptions 
WHERE status = 'active'
GROUP BY DATE_TRUNC('month', current_period_start)
ORDER BY month DESC;

-- è§£ç´„ç†ç”±åˆ†æ
SELECT 
  cancellation_reason,
  COUNT(*) as count,
  ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM subscriptions WHERE cancelled_at IS NOT NULL), 2) as percentage
FROM subscriptions 
WHERE cancelled_at IS NOT NULL 
  AND cancellation_reason IS NOT NULL
GROUP BY cancellation_reason
ORDER BY count DESC;
```

---

## ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 1. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥

#### é«˜é »åº¦ã‚¯ã‚¨ãƒªå¯¾å¿œ
```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ãƒ»æ¨©é™ãƒã‚§ãƒƒã‚¯ç”¨
CREATE INDEX CONCURRENTLY idx_subscriptions_user_status 
  ON subscriptions(user_id, status);

-- æœŸé™ç®¡ç†ç”¨
CREATE INDEX CONCURRENTLY idx_subscriptions_period_management
  ON subscriptions(current_period_end, cancel_at_period_end) 
  WHERE status = 'active';

-- åˆ©ç”¨åˆ¶é™ãƒã‚§ãƒƒã‚¯ç”¨
CREATE INDEX CONCURRENTLY idx_user_usage_period_check
  ON user_usage(user_id, period_end_date, usage_count);

-- å±¥æ­´åˆ†æç”¨
CREATE INDEX CONCURRENTLY idx_usage_history_analytics
  ON usage_history(created_at, feature_type, user_id);
```

#### ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ‹ãƒ³ã‚°è¨­è¨ˆ

```sql
-- usage_historyãƒ†ãƒ¼ãƒ–ãƒ«ã®æœˆæ¬¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³
CREATE TABLE usage_history_y2025m08 PARTITION OF usage_history
  FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');

CREATE TABLE usage_history_y2025m09 PARTITION OF usage_history  
  FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');

-- è‡ªå‹•ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆpg_partmanä½¿ç”¨æ¨å¥¨ï¼‰
```

### 2. ã‚¯ã‚¨ãƒªæœ€é©åŒ–

#### åˆ©ç”¨åˆ¶é™ãƒã‚§ãƒƒã‚¯æœ€é©åŒ–
```sql
-- å˜ä¸€ã‚¯ã‚¨ãƒªã§åˆ©ç”¨å¯å¦åˆ¤å®š
WITH user_status AS (
  SELECT 
    u.user_id,
    u.usage_count,
    u.period_end_date,
    s.status as subscription_status,
    CASE 
      WHEN s.status = 'active' THEN true
      WHEN u.period_end_date < NOW() THEN true  -- ãƒªã‚»ãƒƒãƒˆå¯¾è±¡
      WHEN u.usage_count < 5 THEN true
      ELSE false 
    END as can_use
  FROM user_usage u
  LEFT JOIN subscriptions s ON u.user_id = s.user_id
  WHERE u.user_id = $1
)
SELECT * FROM user_status;
```

---

## ğŸš¨ åˆ¶ç´„ãƒ»åˆ¶é™äº‹é …

### 1. ãƒ‡ãƒ¼ã‚¿åˆ¶ç´„

```sql
-- subscriptionsãƒ†ãƒ¼ãƒ–ãƒ«åˆ¶ç´„
ALTER TABLE subscriptions 
ADD CONSTRAINT check_status_valid 
CHECK (status IN ('active', 'canceled', 'past_due', 'inactive'));

ALTER TABLE subscriptions
ADD CONSTRAINT check_period_logic
CHECK (current_period_end > current_period_start);

-- user_usageãƒ†ãƒ¼ãƒ–ãƒ«åˆ¶ç´„  
ALTER TABLE user_usage
ADD CONSTRAINT check_usage_count_positive
CHECK (usage_count >= 0);

ALTER TABLE user_usage  
ADD CONSTRAINT check_period_logic
CHECK (period_end_date > period_start_date);

-- usage_historyãƒ†ãƒ¼ãƒ–ãƒ«åˆ¶ç´„
ALTER TABLE usage_history
ADD CONSTRAINT check_feature_type_valid
CHECK (feature_type IN ('simulator', 'market_analysis', 'property_share', 'comment', 'profile_update'));
```

### 2. ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«åˆ¶ç´„

| åˆ¶ç´„é …ç›® | ãƒ«ãƒ¼ãƒ« | å®Ÿè£…æ–¹æ³• |
|----------|--------|----------|
| 1ãƒ¦ãƒ¼ã‚¶ãƒ¼1ã‚µãƒ–ã‚¹ã‚¯ | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯1ã¤ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ã¿ | UNIQUEåˆ¶ç´„ |
| åˆ©ç”¨å›æ•°ä¸Šé™ | ç„¡æ–™ãƒ—ãƒ©ãƒ³5å›/30æ—¥ | ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ |
| æœŸé–“ãƒªã‚»ãƒƒãƒˆ | 30æ—¥ã”ã¨ã«è‡ªå‹•ãƒªã‚»ãƒƒãƒˆ | ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢æ•° |
| äºŒé‡æ±ºæ¸ˆé˜²æ­¢ | åŒæ™‚æ±ºæ¸ˆå‡¦ç†ã®é˜²æ­¢ | ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ¶å¾¡ |

### 3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶ç´„

```sql
-- æ©Ÿå¯†æƒ…å ±ã®æš—å·åŒ–ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ç›£æŸ»ãƒ­ã‚°ï¼ˆå°†æ¥å®Ÿè£…ï¼‰
CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  operation TEXT NOT NULL,
  user_id UUID,
  old_values JSONB,
  new_values JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## ğŸ“± ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ‰‹é †

### 1. åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```sql
-- 1. æ‹¡å¼µæ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 2. ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆé †åºï¼ˆä¾å­˜é–¢ä¿‚è€ƒæ…®ï¼‰
-- Step 1: subscriptions
-- Step 2: user_usage  
-- Step 3: usage_history

-- 3. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
-- 4. RLSæœ‰åŠ¹åŒ–ãƒ»ãƒãƒªã‚·ãƒ¼è¨­å®š
-- 5. é–¢æ•°ãƒ»ãƒˆãƒªã‚¬ãƒ¼ä½œæˆ
```

### 2. æœ¬ç•ªç’°å¢ƒãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```bash
#!/bin/bash
# migration_script.sh

echo "Starting database migration..."

# ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
psql $DATABASE_URL -f migrations/001_create_subscriptions.sql
psql $DATABASE_URL -f migrations/002_create_user_usage.sql  
psql $DATABASE_URL -f migrations/003_create_usage_history.sql
psql $DATABASE_URL -f migrations/004_create_indexes.sql
psql $DATABASE_URL -f migrations/005_setup_rls.sql
psql $DATABASE_URL -f migrations/006_create_functions.sql

echo "Migration completed successfully!"
```

### 3. ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †

```sql
-- ç·Šæ€¥æ™‚ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨
DROP TABLE IF EXISTS usage_history CASCADE;
DROP TABLE IF EXISTS user_usage CASCADE;  
DROP TABLE IF EXISTS subscriptions CASCADE;

-- é–¢æ•°ãƒ»ãƒˆãƒªã‚¬ãƒ¼ã‚‚å‰Šé™¤
DROP FUNCTION IF EXISTS check_and_reset_usage(UUID);
DROP FUNCTION IF EXISTS is_premium_user(UUID);
DROP FUNCTION IF EXISTS can_use_feature(UUID, TEXT);
```

---

## ğŸ”® å°†æ¥æ‹¡å¼µè¨ˆç”»

### Phase 2 æ©Ÿèƒ½æ‹¡å¼µï¼ˆ1-3ãƒ¶æœˆï¼‰

#### 1. è¤‡æ•°ãƒ—ãƒ©ãƒ³å¯¾å¿œ
```sql
-- ãƒ—ãƒ©ãƒ³ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«è¿½åŠ 
CREATE TABLE subscription_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_code TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  price INTEGER NOT NULL,
  features JSONB DEFAULT '{}',
  usage_limit INTEGER DEFAULT 5,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µ
ALTER TABLE subscriptions ADD COLUMN plan_id UUID REFERENCES subscription_plans(id);
```

#### 2. ä½¿ç”¨é‡èª²é‡‘å¯¾å¿œ
```sql
-- ä½¿ç”¨é‡èª²é‡‘ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE usage_billing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  billing_period_start TIMESTAMP WITH TIME ZONE,
  billing_period_end TIMESTAMP WITH TIME ZONE,
  base_fee INTEGER DEFAULT 2980,
  usage_fee INTEGER DEFAULT 0,
  total_fee INTEGER,
  usage_details JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Phase 3 é«˜åº¦ãªåˆ†ææ©Ÿèƒ½ï¼ˆ3-6ãƒ¶æœˆï¼‰

#### 1. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ
```sql
-- åˆ†æç”¨ãƒãƒ†ãƒªã‚¢ãƒ©ã‚¤ã‚ºãƒ‰ãƒ“ãƒ¥ãƒ¼
CREATE MATERIALIZED VIEW real_time_metrics AS
SELECT 
  COUNT(DISTINCT CASE WHEN s.status = 'active' THEN s.user_id END) as active_subscribers,
  COUNT(DISTINCT uh.user_id) as active_users_today,
  SUM(CASE WHEN s.status = 'active' THEN 2980 ELSE 0 END) as mrr
FROM subscriptions s
CROSS JOIN usage_history uh 
WHERE uh.created_at >= CURRENT_DATE;

-- è‡ªå‹•æ›´æ–°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
SELECT cron.schedule('refresh-metrics', '*/5 * * * *', 'REFRESH MATERIALIZED VIEW real_time_metrics;');
```

#### 2. æ©Ÿæ¢°å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
```sql  
-- MLç‰¹å¾´é‡ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE ml_features (
  user_id UUID PRIMARY KEY,
  signup_date DATE,
  days_to_first_use INTEGER,
  avg_weekly_usage DECIMAL,
  feature_diversity_score DECIMAL,
  churn_probability DECIMAL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## ğŸ“Š ç›£è¦–ãƒ»ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

### 1. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```sql
-- ã‚¹ãƒ­ãƒ¼ã‚¯ã‚¨ãƒªç›£è¦–
SELECT 
  query,
  mean_exec_time,
  calls,
  total_exec_time
FROM pg_stat_statements 
WHERE query LIKE '%subscriptions%' 
   OR query LIKE '%user_usage%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½¿ç”¨çŠ¶æ³
SELECT 
  schemaname,
  tablename, 
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes 
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 2. å®šæœŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

```bash
#!/bin/bash
# maintenance_script.sh

# å¤ã„å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ï¼ˆ6ãƒ¶æœˆä»¥ä¸Šï¼‰
psql $DATABASE_URL -c "
  INSERT INTO usage_history_archive 
  SELECT * FROM usage_history 
  WHERE created_at < NOW() - INTERVAL '6 months';
  
  DELETE FROM usage_history 
  WHERE created_at < NOW() - INTERVAL '6 months';
"

# VACUUMãƒ»ANALYZEå®Ÿè¡Œ
psql $DATABASE_URL -c "VACUUM ANALYZE subscriptions;"
psql $DATABASE_URL -c "VACUUM ANALYZE user_usage;" 
psql $DATABASE_URL -c "VACUUM ANALYZE usage_history;"

# ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
# psql $DATABASE_URL -c "REINDEX TABLE subscriptions;"
```

### 3. ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š

```sql
-- ç•°å¸¸æ¤œçŸ¥ç”¨ã‚¯ã‚¨ãƒª
WITH subscription_metrics AS (
  SELECT 
    COUNT(*) as total_subscriptions,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_count,
    COUNT(CASE WHEN cancel_at_period_end THEN 1 END) as canceling_count
  FROM subscriptions
)
SELECT 
  *,
  CASE 
    WHEN canceling_count::DECIMAL / active_count > 0.1 
    THEN 'HIGH_CHURN_ALERT' 
    ELSE 'OK' 
  END as alert_status
FROM subscription_metrics;
```

---

## ğŸ“š å‚è€ƒè³‡æ–™ãƒ»é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

### å†…éƒ¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [Stripeé€£æºä»•æ§˜æ›¸](/docs_md/11_ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†/01_ä»•æ§˜æ›¸/Stripeé€£æºä»•æ§˜æ›¸.md)
- [ãƒ—ãƒ©ãƒ³è§£ç´„æ©Ÿèƒ½ä»•æ§˜æ›¸](/docs_md/12_é€€ä¼šå‡¦ç†/çµ±åˆå®Ÿè£…ä»•æ§˜æ›¸_ãƒ—ãƒ©ãƒ³è§£ç´„æ©Ÿèƒ½.md)  
- [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“è¨­è¨ˆæ›¸](/supabase/table.md)

### å¤–éƒ¨ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹
- [Supabase Row Level Security](https://supabase.com/docs/guides/auth/row-level-security)
- [PostgreSQL ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ](https://www.postgresql.org/docs/current/indexes.html)
- [Stripe Subscriptions API](https://stripe.com/docs/api/subscriptions)

---

**æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯å®Ÿè£…ãƒãƒ¼ãƒ ã«ã‚ˆã‚‹ç¶™ç¶šçš„ãªæ›´æ–°å¯¾è±¡ã§ã™**

*æœ€çµ‚æ›´æ–°: 2025å¹´8æœˆ14æ—¥*  
*æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼äºˆå®š: 2025å¹´9æœˆ14æ—¥*  
*ä½œæˆè€…: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆãƒãƒ¼ãƒ *